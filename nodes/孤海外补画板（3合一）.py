import torch
import numpy as np
from PIL import Image, ImageFilter
import math

class 孤海外补画板按目标宽高:
    """
    孤海-外补画板（按目标宽高）
    根据目标宽度和高度进行外补，输出遮罩已反转黑白区域
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "图像": ("IMAGE",),
                "目标宽度": ("INT", {"default": 1024, "min": 100, "max": 20000}),
                "目标高度": ("INT", {"default": 1024, "min": 100, "max": 20000}),
                "左扩比例": ("FLOAT", {"default": 0.5, "min": 0, "max": 1, "step": 0.1}),
                "上扩比例": ("FLOAT", {"default": 0.5, "min": 0, "max": 1, "step": 0.1}),
                "羽化": ("INT", {"default": 0, "min": 0, "max": 500}),
                "整除数": ([0, 8, 16, 32, 64], {"default": 0}),
            },
            "optional": {
                "遮罩": ("MASK",),
            }
        }
    
    RETURN_TYPES = ("IMAGE", "MASK", "BOOLEAN")
    RETURN_NAMES = ("图像", "遮罩", "外补是否存在")
    FUNCTION = "处理"
    CATEGORY = "孤海工具箱"
    
    def 处理(self, 图像, 目标宽度, 目标高度, 左扩比例, 上扩比例, 羽化, 整除数, 遮罩=None):
        # 获取输入图像尺寸
        _, orig_h, orig_w, _ = 图像.shape
        原尺寸 = (orig_w, orig_h)
        
        # 计算扩展信息
        扩展信息 = self._按目标像素扩展(orig_w, orig_h, 目标宽度, 目标高度, 左扩比例, 上扩比例)
        
        # 应用整除数调整
        if 整除数 > 0:
            扩展信息 = self._应用整除数(扩展信息, 整除数)
        
        # 处理图像
        输出图像 = self._创建输出图像(图像, 扩展信息)
        
        # 处理遮罩（此处调用逻辑不变，但内部实现已反转）
        输出遮罩 = self._创建输出遮罩(遮罩, 扩展信息, 原尺寸, 羽化)
        
        # 检查是否存在外补区域
        外补是否存在 = self._检查外补(扩展信息, 原尺寸)
        
        return (输出图像, 输出遮罩, 外补是否存在)
    
    def _按目标像素扩展(self, 原宽, 原高, 目标宽, 目标高, 左扩比例, 上扩比例):
        """按目标像素模式扩展逻辑（无修改）"""
        if 目标宽 >= 原宽 and 目标高 >= 原高:
            缩放宽, 缩放高 = 原宽, 原高
        else:
            比例 = min(目标宽 / 原宽, 目标高 / 原高)
            缩放宽 = int(原宽 * 比例)
            缩放高 = int(原高 * 比例)
        
        扩展宽 = 目标宽 - 缩放宽
        扩展高 = 目标高 - 缩放高
        
        if 扩展宽 >= 0:
            左 = int(扩展宽 * 左扩比例)
            右 = 扩展宽 - 左
        else:
            左裁剪 = int(abs(扩展宽) * 左扩比例)
            右裁剪 = abs(扩展宽) - 左裁剪
            左 = -左裁剪
            右 = -右裁剪
            
        if 扩展高 >= 0:
            上 = int(扩展高 * 上扩比例)
            下 = 扩展高 - 上
        else:
            上裁剪 = int(abs(扩展高) * 上扩比例)
            下裁剪 = abs(扩展高) - 上裁剪
            上 = -上裁剪
            下 = -下裁剪

        return {
            "目标宽": 目标宽,
            "目标高": 目标高,
            "缩放宽": 缩放宽,
            "缩放高": 缩放高,
            "左": 左,
            "上": 上,
            "右": 右,
            "下": 下
        }
    
    def _应用整除数(self, 扩展信息, 整除数):
        """应用整除数调整逻辑（无修改）"""
        if 整除数 <= 0:
            return 扩展信息
            
        调整宽 = ((扩展信息["目标宽"] + 整除数 - 1) // 整除数) * 整除数
        调整高 = ((扩展信息["目标高"] + 整除数 - 1) // 整除数) * 整除数
        
        额外宽 = 调整宽 - 扩展信息["目标宽"]
        额外高 = 调整高 - 扩展信息["目标高"]
        
        总宽 = 扩展信息["左"] + 扩展信息["右"]
        总高 = 扩展信息["上"] + 扩展信息["下"]
        
        if 总宽 > 0:
            左比例 = 扩展信息["左"] / 总宽
            扩展信息["左"] += int(额外宽 * 左比例)
            扩展信息["右"] += 额外宽 - int(额外宽 * 左比例)
        else:
            扩展信息["左"] += 额外宽 // 2
            扩展信息["右"] += 额外宽 - 额外宽 // 2
        
        if 总高 > 0:
            上比例 = 扩展信息["上"] / 总高
            扩展信息["上"] += int(额外高 * 上比例)
            扩展信息["下"] += 额外高 - int(额外高 * 上比例)
        else:
            扩展信息["上"] += 额外高 // 2
            扩展信息["下"] += 额外高 - 额外高 // 2
        
        扩展信息["目标宽"] = 调整宽
        扩展信息["目标高"] = 调整高
        
        return 扩展信息
    
    def _创建输出图像(self, 图像, 扩展信息):
        目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
        结果 = torch.full((1, 目标高, 目标宽, 3), 0.5, dtype=torch.float32)
        
        原始图像 = 图像
        
        左, 上 = 扩展信息["左"], 扩展信息["上"]
        缩放宽, 缩放高 = 扩展信息["缩放宽"], 扩展信息["缩放高"]
        
        if 缩放宽 != 原始图像.shape[2] or 缩放高 != 原始图像.shape[1]:
            原始图像 = torch.nn.functional.interpolate(
                原始图像.permute(0, 3, 1, 2), 
                size=(缩放高, 缩放宽), 
                mode='bilinear', 
                align_corners=False
            ).permute(0, 2, 3, 1)
        
        放置左 = max(0, 左)
        放置上 = max(0, 上)
        图像左 = max(0, -左)
        图像上 = max(0, -上)
        
        实际宽 = min(缩放宽 - 图像左, 目标宽 - 放置左)
        实际高 = min(缩放高 - 图像上, 目标高 - 放置上)
        
        结果[:, 放置上:放置上+实际高, 放置左:放置左+实际宽, :] = 原始图像[:, 图像上:图像上+实际高, 图像左:图像左+实际宽, :]
        
        return 结果
    
    def _创建输出遮罩(self, 遮罩, 扩展信息, 原尺寸, 羽化):
        """创建输出遮罩逻辑（核心修改：反转黑白区域）"""
        目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
        原宽, 原高 = 原尺寸
        

        if 遮罩 is None:

            # 反转后：原图区域=0.0（黑），外扩区域=1.0（白）
            基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)  # 先全白
            放置左 = max(0, 扩展信息["左"])
            放置上 = max(0, 扩展信息["上"])
            实际宽 = min(扩展信息["缩放宽"], 目标宽 - 放置左)
            实际高 = min(扩展信息["缩放高"], 目标高 - 放置上)
            基础遮罩[放置上:放置上+实际高, 放置左:放置左+实际宽] = 0.0  # 原图区域设为黑
        else:

            # 反转后：输入遮罩区域取反（白→黑，黑→白），外扩区域=1.0（白）
            基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)  # 先全白（外扩区域默认白）
            
            # 调整输入遮罩尺寸到原始图像尺寸
            if 遮罩.shape[1:3] != (原高, 原宽):
                遮罩 = torch.nn.functional.interpolate(
                    遮罩.unsqueeze(0).unsqueeze(0), 
                    size=(原高, 原宽), 
                    mode='bilinear', 
                    align_corners=False
                ).squeeze(0).squeeze(0)
            
            # 缩放遮罩到缩放宽高
            if 扩展信息["缩放宽"] != 原宽 or 扩展信息["缩放高"] != 原高:
                遮罩 = torch.nn.functional.interpolate(
                    遮罩.unsqueeze(0).unsqueeze(0), 
                    size=(扩展信息["缩放高"], 扩展信息["缩放宽"]), 
                    mode='bilinear', 
                    align_corners=False
                ).squeeze(0).squeeze(0)
            
            # 计算放置位置
            放置左 = max(0, 扩展信息["左"])
            放置上 = max(0, 扩展信息["上"])
            图像左 = max(0, -扩展信息["左"])
            图像上 = max(0, -扩展信息["上"])
            实际宽 = min(扩展信息["缩放宽"] - 图像左, 目标宽 - 放置左)
            实际高 = min(扩展信息["缩放高"] - 图像上, 目标高 - 放置上)
            
            # 输入遮罩区域取反（1.0→0.0，0.5→0.5，0.0→1.0）
            反转后遮罩 = 1.0 - 遮罩[图像上:图像上+实际高, 图像左:图像左+实际宽]
            # 放置反转后的遮罩（原图区域变为反转后的颜色，外扩区域保持全白）
            基础遮罩[放置上:放置上+实际高, 放置左:放置左+实际宽] = 反转后遮罩
        
        if 羽化 > 0:
            遮罩数组 = (基础遮罩.numpy() * 255).astype(np.uint8)
            图像遮罩 = Image.fromarray(遮罩数组)
            图像遮罩 = 图像遮罩.filter(ImageFilter.GaussianBlur(radius=羽化))
            基础遮罩 = torch.from_numpy(np.array(图像遮罩).astype(np.float32) / 255.0)
        
        return 基础遮罩.unsqueeze(0)
    
    def _检查外补(self, 扩展信息, 原尺寸):
        """检查是否存在外补区域（无修改）"""
        原宽, 原高 = 原尺寸
        return (扩展信息["目标宽"] > 原宽 or 
                扩展信息["目标高"] > 原高 or
                扩展信息["左"] > 0 or
                扩展信息["右"] > 0 or
                扩展信息["上"] > 0 or
                扩展信息["下"] > 0)

##########################################################################
class 孤海外补画板按比例:
    """
    孤海-外补画板（按比例）
    根据宽高比例进行外补
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "图像": ("IMAGE",),
                "比例宽": ("INT", {"default": 1, "min": 1, "max": 100}),
                "比例高": ("INT", {"default": 1, "min": 1, "max": 100}),
                "左扩比例": ("FLOAT", {"default": 0.5, "min": 0, "max": 1, "step": 0.1}),
                "上扩比例": ("FLOAT", {"default": 0.5, "min": 0, "max": 1, "step": 0.1}),
                "羽化": ("INT", {"default": 0, "min": 0, "max": 500}),
                "整除数": ([0, 8, 16, 32, 64], {"default": 0}),
            },
            "optional": {
                "遮罩": ("MASK",),
            }
        }
    
    RETURN_TYPES = ("IMAGE", "MASK", "BOOLEAN")
    RETURN_NAMES = ("图像", "遮罩", "外补是否存在")
    FUNCTION = "处理"
    CATEGORY = "孤海工具箱"
    
    def 处理(self, 图像, 比例宽, 比例高, 左扩比例, 上扩比例, 羽化, 整除数, 遮罩=None):
        # 获取输入图像尺寸
        _, orig_h, orig_w, _ = 图像.shape
        原尺寸 = (orig_w, orig_h)
        
        # 计算扩展信息
        扩展信息 = self._按比例扩展(orig_w, orig_h, 比例宽, 比例高, 左扩比例, 上扩比例)
        
        # 应用整除数调整
        if 整除数 > 0:
            扩展信息 = self._应用整除数(扩展信息, 整除数)
        
        # 处理图像
        输出图像 = self._创建输出图像(图像, 扩展信息)
        
        # 处理遮罩
        输出遮罩 = self._创建输出遮罩(遮罩, 扩展信息, 原尺寸, 羽化)
        
        # 检查是否存在外补区域
        外补是否存在 = self._检查外补(扩展信息, 原尺寸)
        
        return (输出图像, 输出遮罩, 外补是否存在)
    
    def _按比例扩展(self, 原宽, 原高, 比例宽, 比例高, 左扩比例, 上扩比例):
        """按比例模式扩展逻辑"""
        原比例 = 原宽 / 原高
        目标比例 = 比例宽 / 比例高
        
        if 原比例 > 目标比例:
            # 需要扩展高度
            目标高 = int(原宽 * 比例高 / 比例宽)
            目标宽 = 原宽
        else:
            # 需要扩展宽度
            目标宽 = int(原高 * 比例宽 / 比例高)
            目标高 = 原高
        
        # 计算扩展量
        扩展宽 = max(0, 目标宽 - 原宽)
        扩展高 = max(0, 目标高 - 原高)
        
        # 计算偏移
        左 = int(扩展宽 * 左扩比例)
        上 = int(扩展高 * 上扩比例)
        
        return {
            "目标宽": 目标宽,
            "目标高": 目标高,
            "缩放宽": 原宽,
            "缩放高": 原高,
            "左": 左,
            "上": 上,
            "右": 扩展宽 - 左,
            "下": 扩展高 - 上
        }
    
    def _应用整除数(self, 扩展信息, 整除数):
        """应用整除数调整逻辑"""
        if 整除数 <= 0:
            return 扩展信息
            
        # 计算调整后的尺寸
        调整宽 = ((扩展信息["目标宽"] + 整除数 - 1) // 整除数) * 整除数
        调整高 = ((扩展信息["目标高"] + 整除数 - 1) // 整除数) * 整除数
        
        # 计算额外的扩展量
        额外宽 = 调整宽 - 扩展信息["目标宽"]
        额外高 = 调整高 - 扩展信息["目标高"]
        
        # 按比例分配额外扩展量
        总宽 = 扩展信息["左"] + 扩展信息["右"]
        总高 = 扩展信息["上"] + 扩展信息["下"]
        
        if 总宽 > 0:
            左比例 = 扩展信息["左"] / 总宽
            扩展信息["左"] += int(额外宽 * 左比例)
            扩展信息["右"] += 额外宽 - int(额外宽 * 左比例)
        else:
            扩展信息["左"] += 额外宽 // 2
            扩展信息["右"] += 额外宽 - 额外宽 // 2
        
        if 总高 > 0:
            上比例 = 扩展信息["上"] / 总高
            扩展信息["上"] += int(额外高 * 上比例)
            扩展信息["下"] += 额外高 - int(额外高 * 上比例)
        else:
            扩展信息["上"] += 额外高 // 2
            扩展信息["下"] += 额外高 - 额外高 // 2
        
        扩展信息["目标宽"] = 调整宽
        扩展信息["目标高"] = 调整高
        
        return 扩展信息
    
    def _创建输出图像(self, 图像, 扩展信息):
        """创建输出图像逻辑"""
        # 创建灰色背景 (RGB模式，灰色值为0.5)
        目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
        结果 = torch.full((1, 目标高, 目标宽, 3), 0.5, dtype=torch.float32)
        
        # 获取原始图像
        原始图像 = 图像
        
        # 放置原始图像
        左, 上 = 扩展信息["左"], 扩展信息["上"]
        缩放宽, 缩放高 = 扩展信息["缩放宽"], 扩展信息["缩放高"]
        
        # 如果尺寸不匹配，需要调整图像大小
        if 缩放宽 != 原始图像.shape[2] or 缩放高 != 原始图像.shape[1]:
            # 使用torch.nn.functional.interpolate进行缩放
            原始图像 = torch.nn.functional.interpolate(
                原始图像.permute(0, 3, 1, 2), 
                size=(缩放高, 缩放宽), 
                mode='bilinear', 
                align_corners=False
            ).permute(0, 2, 3, 1)
        
        # 将原始图像放置到正确位置
        结果[:, 上:上+缩放高, 左:左+缩放宽, :] = 原始图像
        
        return 结果
    
    def _创建输出遮罩(self, 遮罩, 扩展信息, 原尺寸, 羽化):
        """创建输出遮罩逻辑（已修正黑白反转）"""
        目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
        原宽, 原高 = 原尺寸
        
        # 创建基础遮罩
        if 遮罩 is None:
            # 没有输入遮罩：原图区域为黑色，外扩区域为白色（与原逻辑相反）
            基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)
            基础遮罩[扩展信息["上"]:扩展信息["上"]+原高, 
                    扩展信息["左"]:扩展信息["左"]+原宽] = 0.0
        else:
            # 有输入遮罩：保持原始遮罩的反转，外扩区域为白色（与原逻辑相反）
            基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)
            
            # 处理原始遮罩区域
            if 遮罩.shape[1:3] != (原高, 原宽):
                # 调整遮罩尺寸
                遮罩 = torch.nn.functional.interpolate(
                    遮罩.unsqueeze(0).unsqueeze(0), 
                    size=(原高, 原宽), 
                    mode='bilinear', 
                    align_corners=False
                ).squeeze(0).squeeze(0)
            
            # 反转原始遮罩
            基础遮罩[扩展信息["上"]:扩展信息["上"]+原高, 
                    扩展信息["左"]:扩展信息["左"]+原宽] = 1 - 遮罩
        
        # 应用羽化效果
        if 羽化 > 0:
            # 转换为PIL图像进行羽化处理
            遮罩数组 = (基础遮罩.numpy() * 255).astype(np.uint8)
            图像遮罩 = Image.fromarray(遮罩数组)
            
            # 应用高斯模糊实现羽化
            图像遮罩 = 图像遮罩.filter(ImageFilter.GaussianBlur(radius=羽化))
            
            # 转换回tensor
            基础遮罩 = torch.from_numpy(np.array(图像遮罩).astype(np.float32) / 255.0)
        
        return 基础遮罩.unsqueeze(0)
    
    def _检查外补(self, 扩展信息, 原尺寸):
        """检查是否存在外补区域"""
        原宽, 原高 = 原尺寸
        return (扩展信息["目标宽"] > 原宽 or 
                扩展信息["目标高"] > 原高 or
                扩展信息["左"] > 0 or
                扩展信息["右"] > 0 or
                扩展信息["上"] > 0 or
                扩展信息["下"] > 0)

############################################################################


class 孤海外补画板按方向:
    """
    孤海-外补画板（按方向）
    根据四个方向的扩展量进行外补
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "图像": ("IMAGE",),
                "单位": (["像素", "百分比"], {"default": "像素"}),
                "左": ("INT", {"default": 0, "min": 0, "max": 3000}),
                "右": ("INT", {"default": 0, "min": 0, "max": 3000}),
                "上": ("INT", {"default": 0, "min": 0, "max": 3000}),
                "下": ("INT", {"default": 0, "min": 0, "max": 3000}),
                "羽化": ("INT", {"default": 0, "min": 0, "max": 500}),
                "整除数": ([0, 8, 16, 32, 64], {"default": 0}),
            },
            "optional": {
                "遮罩": ("MASK",),
            }
        }
    
    RETURN_TYPES = ("IMAGE", "MASK", "BOOLEAN")
    RETURN_NAMES = ("图像", "遮罩", "外补是否存在")
    FUNCTION = "处理"
    CATEGORY = "孤海工具箱"
    
    def 处理(self, 图像, 单位, 左, 右, 上, 下, 羽化, 整除数, 遮罩=None):
        # 获取输入图像尺寸
        _, orig_h, orig_w, _ = 图像.shape
        原尺寸 = (orig_w, orig_h)
        
        # 检查是否需要裁剪模式
        裁剪模式 = (左 == 0 and 右 == 0 and 上 == 0 and 下 == 0 and 整除数 > 0)
        
        # 计算扩展信息
        扩展信息 = self._按方向扩展(orig_w, orig_h, 单位, 左, 右, 上, 下)
        
        # 应用整除数调整
        if 整除数 > 0:
            扩展信息 = self._应用整除数(扩展信息, 整除数, 裁剪模式)
        
        # 处理图像
        输出图像 = self._创建输出图像(图像, 扩展信息, 裁剪模式)
        
        # 处理遮罩
        输出遮罩 = self._创建输出遮罩(遮罩, 扩展信息, 原尺寸, 羽化, 裁剪模式)
        
        # 检查是否存在外补区域
        外补是否存在 = self._检查外补(扩展信息, 原尺寸, 裁剪模式)
        
        return (输出图像, 输出遮罩, 外补是否存在)
    
    def _按方向扩展(self, 原宽, 原高, 单位, 左, 右, 上, 下):
        """按方向模式扩展逻辑"""
        # 处理百分比单位
        if 单位 == "百分比":
            左 = int(原宽 * 左 / 100)
            右 = int(原宽 * 右 / 100)
            上 = int(原高 * 上 / 100)
            下 = int(原高 * 下 / 100)
        
        return {
            "目标宽": 原宽 + 左 + 右,
            "目标高": 原高 + 上 + 下,
            "缩放宽": 原宽,
            "缩放高": 原高,
            "左": 左,
            "上": 上,
            "右": 右,
            "下": 下
        }
    
    def _应用整除数(self, 扩展信息, 整除数, 裁剪模式):
        """应用整除数调整逻辑"""
        if 整除数 <= 0:
            return 扩展信息
            
        if 裁剪模式:
            # 裁剪模式：向下取整到最近的整除数倍数
            调整宽 = (扩展信息["目标宽"] // 整除数) * 整除数
            调整高 = (扩展信息["目标高"] // 整除数) * 整除数
            
            # 计算需要裁剪的量
            裁剪宽 = 扩展信息["目标宽"] - 调整宽
            裁剪高 = 扩展信息["目标高"] - 调整高
            
            # 按比例分配裁剪量
            总宽 = 扩展信息["左"] + 扩展信息["右"]
            总高 = 扩展信息["上"] + 扩展信息["下"]
            
            if 总宽 > 0:
                左比例 = 扩展信息["左"] / 总宽
                扩展信息["左"] -= int(裁剪宽 * 左比例)
                扩展信息["右"] -= 裁剪宽 - int(裁剪宽 * 左比例)
            else:
                扩展信息["左"] -= 裁剪宽 // 2
                扩展信息["右"] -= 裁剪宽 - 裁剪宽 // 2
            
            if 总高 > 0:
                上比例 = 扩展信息["上"] / 总高
                扩展信息["上"] -= int(裁剪高 * 上比例)
                扩展信息["下"] -= 裁剪高 - int(裁剪高 * 上比例)
            else:
                扩展信息["上"] -= 裁剪高 // 2
                扩展信息["下"] -= 裁剪高 - 裁剪高 // 2
        else:
            # 扩展模式：向上取整到最近的整除数倍数
            调整宽 = ((扩展信息["目标宽"] + 整除数 - 1) // 整除数) * 整除数
            调整高 = ((扩展信息["目标高"] + 整除数 - 1) // 整除数) * 整除数
            
            # 计算额外的扩展量
            额外宽 = 调整宽 - 扩展信息["目标宽"]
            额外高 = 调整高 - 扩展信息["目标高"]
            
            # 按比例分配额外扩展量
            总宽 = 扩展信息["左"] + 扩展信息["右"]
            总高 = 扩展信息["上"] + 扩展信息["下"]
            
            if 总宽 > 0:
                左比例 = 扩展信息["左"] / 总宽
                扩展信息["左"] += int(额外宽 * 左比例)
                扩展信息["右"] += 额外宽 - int(额外宽 * 左比例)
            else:
                扩展信息["左"] += 额外宽 // 2
                扩展信息["右"] += 额外宽 - 额外宽 // 2
            
            if 总高 > 0:
                上比例 = 扩展信息["上"] / 总高
                扩展信息["上"] += int(额外高 * 上比例)
                扩展信息["下"] += 额外高 - int(额外高 * 上比例)
            else:
                扩展信息["上"] += 额外高 // 2
                扩展信息["下"] += 额外高 - 额外高 // 2
        
        扩展信息["目标宽"] = 调整宽
        扩展信息["目标高"] = 调整高
        
        return 扩展信息
    
    def _创建输出图像(self, 图像, 扩展信息, 裁剪模式):
        """创建输出图像逻辑"""
        if 裁剪模式:
            # 裁剪模式：直接裁剪原始图像
            左, 上 = 扩展信息["左"], 扩展信息["上"]
            目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
            
            # 如果左或上为负数，需要调整裁剪区域
            裁剪左 = max(0, -左)
            裁剪上 = max(0, -上)
            
            # 计算实际裁剪区域
            实际宽 = min(目标宽, 图像.shape[2] - 裁剪左)
            实际高 = min(目标高, 图像.shape[1] - 裁剪上)
            
            # 裁剪图像
            输出图像 = 图像[:, 裁剪上:裁剪上+实际高, 裁剪左:裁剪左+实际宽, :]
            
            # 如果需要调整大小（通常不需要，因为裁剪模式是向下取整）
            if 输出图像.shape[1] != 目标高 or 输出图像.shape[2] != 目标宽:
                输出图像 = torch.nn.functional.interpolate(
                    输出图像.permute(0, 3, 1, 2), 
                    size=(目标高, 目标宽), 
                    mode='bilinear', 
                    align_corners=False
                ).permute(0, 2, 3, 1)
            
            return 输出图像
        else:
            # 扩展模式：创建灰色背景并放置原始图像
            目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
            结果 = torch.full((1, 目标高, 目标宽, 3), 0.5, dtype=torch.float32)
            
            # 获取原始图像
            原始图像 = 图像
            
            # 放置原始图像
            左, 上 = 扩展信息["左"], 扩展信息["上"]
            缩放宽, 缩放高 = 扩展信息["缩放宽"], 扩展信息["缩放高"]
            
            # 如果尺寸不匹配，需要调整图像大小
            if 缩放宽 != 原始图像.shape[2] or 缩放高 != 原始图像.shape[1]:
                原始图像 = torch.nn.functional.interpolate(
                    原始图像.permute(0, 3, 1, 2), 
                    size=(缩放高, 缩放宽), 
                    mode='bilinear', 
                    align_corners=False
                ).permute(0, 2, 3, 1)
            
            # 将原始图像放置到正确位置
            放置左 = max(0, 左)
            放置上 = max(0, 上)
            图像左 = max(0, -左)
            图像上 = max(0, -上)
            
            实际宽 = min(缩放宽 - 图像左, 目标宽 - 放置左)
            实际高 = min(缩放高 - 图像上, 目标高 - 放置上)
            
            结果[:, 放置上:放置上+实际高, 放置左:放置左+实际宽, :] = 原始图像[:, 图像上:图像上+实际高, 图像左:图像左+实际宽, :]
            
            return 结果
    
    def _创建输出遮罩(self, 遮罩, 扩展信息, 原尺寸, 羽化, 裁剪模式):
        """创建输出遮罩逻辑"""
        目标宽, 目标高 = 扩展信息["目标宽"], 扩展信息["目标高"]
        原宽, 原高 = 原尺寸
        
        if 裁剪模式:
            # 裁剪模式：直接裁剪原始遮罩或创建全白遮罩
            if 遮罩 is None:
                # 没有输入遮罩：创建全白遮罩
                基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)
            else:
                # 有输入遮罩：裁剪原始遮罩
                左, 上 = 扩展信息["左"], 扩展信息["上"]
                
                # 如果左或上为负数，需要调整裁剪区域
                裁剪左 = max(0, -左)
                裁剪上 = max(0, -上)
                
                # 计算实际裁剪区域
                实际宽 = min(目标宽, 遮罩.shape[2] - 裁剪左)
                实际高 = min(目标高, 遮罩.shape[1] - 裁剪上)
                
                # 裁剪遮罩
                基础遮罩 = 遮罩[裁剪上:裁剪上+实际高, 裁剪左:裁剪左+实际宽]
                
                # 如果需要调整大小
                if 基础遮罩.shape[0] != 目标高 or 基础遮罩.shape[1] != 目标宽:
                    基础遮罩 = torch.nn.functional.interpolate(
                        基础遮罩.unsqueeze(0).unsqueeze(0), 
                        size=(目标高, 目标宽), 
                        mode='bilinear', 
                        align_corners=False
                    ).squeeze(0).squeeze(0)
        else:
            # 扩展模式：创建基础遮罩
            if 遮罩 is None:
                # 没有输入遮罩：原图区域为黑色，外扩区域为白色
                基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)
                基础遮罩[扩展信息["上"]:扩展信息["上"]+原高, 
                        扩展信息["左"]:扩展信息["左"]+原宽] = 0.0
            else:
                # 有输入遮罩：保持原始遮罩的反转，外扩区域为白色
                基础遮罩 = torch.ones((目标高, 目标宽), dtype=torch.float32)
                
                # 处理原始遮罩区域
                if 遮罩.shape[1:3] != (原高, 原宽):
                    # 调整遮罩尺寸
                    遮罩 = torch.nn.functional.interpolate(
                        遮罩.unsqueeze(0).unsqueeze(0), 
                        size=(原高, 原宽), 
                        mode='bilinear', 
                        align_corners=False
                    ).squeeze(0).squeeze(0)
                
                # 反转原始遮罩
                基础遮罩[扩展信息["上"]:扩展信息["上"]+原高, 
                        扩展信息["左"]:扩展信息["左"]+原宽] = 1 - 遮罩
        
        # 应用羽化效果
        if 羽化 > 0:
            # 转换为PIL图像进行羽化处理
            遮罩数组 = (基础遮罩.numpy() * 255).astype(np.uint8)
            图像遮罩 = Image.fromarray(遮罩数组)
            
            # 应用高斯模糊实现羽化
            图像遮罩 = 图像遮罩.filter(ImageFilter.GaussianBlur(radius=羽化))
            
            # 转换回tensor
            基础遮罩 = torch.from_numpy(np.array(图像遮罩).astype(np.float32) / 255.0)
        
        return 基础遮罩.unsqueeze(0)
    
    def _检查外补(self, 扩展信息, 原尺寸, 裁剪模式):
        """检查是否存在外补区域"""
        if 裁剪模式:
            return False  # 裁剪模式下不存在外补区域
        
        原宽, 原高 = 原尺寸
        return (扩展信息["目标宽"] > 原宽 or 
                扩展信息["目标高"] > 原高 or
                扩展信息["左"] > 0 or
                扩展信息["右"] > 0 or
                扩展信息["上"] > 0 or
                扩展信息["下"] > 0)


# 节点注册
NODE_CLASS_MAPPINGS = {
    "孤海外补画板按目标宽高": 孤海外补画板按目标宽高,
    "孤海外补画板按比例": 孤海外补画板按比例,
    "孤海外补画板按方向": 孤海外补画板按方向
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "孤海外补画板按目标宽高": "孤海-外补画板（按目标宽高）",
    "孤海外补画板按比例": "孤海-外补画板（按比例）",
    "孤海外补画板按方向": "孤海-外补画板（按方向）"
}